# -*- coding: utf-8 -*-
"""Copy of single-view-mpi.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1igVvD5z8liJ-1I_4MaKN480AnP0vcjIy

Copyright 2020 Google LLC.

Licensed under the Apache License, Version 2.0 (the \"License\")
"""

# @title License
# Licensed under the Apache License, Version 2.0 (the \"License\");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an \"AS IS\" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""# Single image to MPI example Colab

This Colab is part of code for the paper ___Single-view view synthesis with multiplane images___, and may be found at <br>https://github.com/google-research/google-research/tree/master/single_view_mpi.

The project site is at https://single-view-mpi.github.io/.

Choose __Run all__ from the Runtime menu to:
* set up the network and load our trained model,
* apply it to an RGB input to generate a 32-layer MPI,
* show individual MPI layers and synthesized disparity,
* render novel views from different camera positions,
* visualize the resulting MPI in an HTML-based viewer.

## Download library code, model weights, and example image.
"""

# Commented out IPython magic to ensure Python compatibility.
# %%capture
# !echo Fetching code from github...
# !apt install subversion
# !svn export --force https://github.com/google-research/google-research/trunk/single_view_mpi
#
# !echo
# !echo Fetching trained model weights...
# !rm single_view_mpi_full_keras.tar.gz
# !rm -rf single_view_mpi_full
# !wget https://storage.googleapis.com/stereo-magnification-public-files/models/single_view_mpi_full_keras.tar.gz
# !tar -xzvf single_view_mpi_full_keras.tar.gz
#
# !echo
# !echo Fetching example image...
# !rm -f input.png
# !wget https://single-view-mpi.github.io/mpi/7/input.png
#


"""## Set up the model

"""

# Commented out IPython magic to ensure Python compatibility.
# %%capture
# pip install -r single_view_mpi/requirements.txt




import matplotlib.pyplot as plt
import numpy as np
import os
import tensorflow as tf
from single_view_mpi.libs import mpi
from single_view_mpi.libs import nets
def generate_mpi(input_dir, output_dir, output_height, output_width, padding):
    input = tf.keras.Input(shape=(None, None, 3))
    output = nets.mpi_from_image(input)

    model = tf.keras.Model(inputs=input, outputs=output)
    print('Model created.')
    # Our full model, trained on RealEstate10K.
    model.load_weights(
        'single_view_mpi_full_keras/single_view_mpi_keras_weights')
    print('Weights loaded.')

    """# Alter Image"""

    for pano_num, f in os.listdir():
        inputfile = f'{input_dir}/{f}'
        input_rgb = tf.image.decode_image(
            tf.io.read_file(inputfile), dtype=tf.float32)

        y_val = output_width-padding*2

        input_rgb = tf.clip_by_value(tf.image.resize(
            input_rgb, (output_height, y_val), method='area'), 0.0, 1.0)

        left = input_rgb[:, 0:padding]
        right = input_rgb[:, y_val-padding:y_val]

        input_rgb = np.concatenate((right, input_rgb, left), axis=1)

       # plt.rcParams["figure.figsize"] = (20, 10)

        # Input image
        #inputfile = 'courtyard.png'
        #input_rgb = tf.image.decode_image(tf.io.read_file(inputfile), dtype=tf.float32)
        # print(input_rgb.shape)

        # default is bilinearly sampler, area (change it to different sampler)
        #input_rgb = tf.clip_by_value(tf.image.resize(input_rgb, (1024, 8192), method='gaussian'), 0.0, 1.0)
        # different powers of 2

        # plt.imshow(input_rgb)

        # Generate MPI
        layers = model(input_rgb[tf.newaxis])[0]
        depths = mpi.make_depths(1.0, 100.0, 32).numpy()

        # Layers is now a tensor of shape [L, H, W, 4].
        # This represents an MPI with L layers, each of height H and width W, and
        # each with an RGB+Alpha 4-channel image.

        # Depths is a tensor of shape [L] which gives the depths of the L layers.

        # Display layer images
        # for i in range(32):
        #    plt.subplot(4, 8, i+1)
        #    plt.imshow(layers[i])
        #    plt.axis('off')
        #    plt.title('Layer %d' % i, loc='left')
        # plt.show()

        # Display computed disparity
        disparity = mpi.disparity_from_layers(layers, depths)
        #plt.imshow(disparity[..., 0])
        # plt.axis('off')
        #plt.title('Synthesized disparity')
        # plt.show()

        plt.imsave(f'{output_dir}/depth_map_{pano_num}.png',
                   disparity[..., 0][:, padding:output_width-padding], cmap='gray')

        os.mkdir(f'{output_dir}/layers_{pano_num}')

        for i in range(32):
            # plt.imshow(layers[i][:,padding:8192-padding])
            # print(layers[i][:,padding:1024-padding].shape)
            plt.imsave(f'{output_dir}/layers_{pano_num}/courtyard_{i}.png',
                       layers[i].numpy()[:, padding:output_width-padding])
            # print(i)


if __name__ == '__main__':
    from configargparse import ArgumentParser
    import glob
    import os

    parser = ArgumentParser(
        description='Generate Single View MPIs'
    )

    parser.add_argument('--input',
                        required=True,
                        help='image or directory containing input images')
    parser.add_argument('--output', '-o',
                        required=True,
                        help='directory for cylindrical output')
    parser.add_argument('--output_width',
                        required=True,
                        type=int,
                        help='width of output panorama parallax layers -- should be power of two')
    parser.add_argument('--output_height',
                        required=True,
                        type=int,
                        help='height of output panorama parallax layers')
    parser.add_argument('--padding',
                        required=True,
                        type=float,
                        help='image padding')

    args = parser.parse_args()

    # verify/create the output directory

    try:
        os.makedirs(args.output_dir)
    except:
        pass

    generate_mpi(args.input_dir, args.output_dir,
                 args.output_height, args.output_width, args.padding)
