<!DOCTYPE html>
<html lang="en">
    <head>
        <title>cylinder map mpi example</title>
        <meta charset="utf-8" />
        <meta
            name="viewport"
            content="width=device-width, initial-scale=1.0, user-scalable=no"
        />
        <link type="text/css" rel="stylesheet" href="main.css" />
    </head>
    <body>
        <div id="container"></div>

        <script src="js/three.js"></script>

        <script id="plainVertexShader" type="x-shader/x-vertex">
            varying highp vec2 vUv;
            void main() {
                vUv = vec2(1.-uv.x,uv.y);
                vec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);
                gl_Position = projectionMatrix * modelViewPosition; 
            }
        </script>

        <script id="plainFragmentShader" type="x-shader/x-fragment">
            uniform sampler2D tColor;
            varying highp vec2 vUv;
            void main() {
                gl_FragColor = texture2D(tColor,vUv);
            }
        </script>

        <script id="mpiVertexShader" type="x-shader/x-vertex">
            varying highp vec2 vUv;
            uniform mat3 vUvTransform;
            void main() {
                vUv = (vUvTransform * vec3(uv.x,uv.y,1.)).xy;
                vec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);
                gl_Position = projectionMatrix * modelViewPosition; 
            }
        </script>

        <script id="mpiFragmentShader" type="x-shader/x-fragment">
            uniform sampler2D tColor;
            varying highp vec2 vUv;
            void main() {
                vec4 rgba = texture2D(tColor,vUv);
                gl_FragColor = rgba;
                //gl_FragColor = vec4(rgba.a,0,0,1);
            }
        </script>

        <script id="depthVertexShader" type="x-shader/x-vertex">
            uniform sampler2D tDisparity;
            varying highp vec2 vUv;
            void main() {
                vUv = vec2(1.-uv.x,uv.y);
                float disparity = texture2D(tDisparity,vUv).r;
                vec4 modelViewPosition = modelViewMatrix * vec4(position/disparity, 1.0);
                gl_Position = projectionMatrix * modelViewPosition; 
            }
        </script>

        <script id="depthFragmentShader" type="x-shader/x-fragment">
            uniform sampler2D tColor;
            uniform sampler2D tDisparity;
            varying highp vec2 vUv;
            void main() {
                gl_FragColor = texture2D(tColor,vUv);
                //gl_FragColor = texture2D(tDisparity,vUv);
                //gl_FragColor = vec4(1.0,0.0,0.0,1.0);
                //gl_FragColor = vec4(vUv,0.0,1.0);
            }
        </script>

        <script type="module">
            var parseQueryString = function() {

                var str = window.location.search;
                var objURL = {};

                str.replace(
                    new RegExp( "([^?=&]+)(=([^&]*))?", "g" ),
                    function( $0, $1, $2, $3 ){
                        objURL[ $1 ] = $3;
                    }
                );
                return objURL;
            };

            import { VRButton } from './js/VRButton.js';
            import { StereoEffect } from 'https://threejs.org/examples/jsm/effects/StereoEffect.js';

            let camera, effect, scene, renderer, sphere, clock;
        
            const params = parseQueryString();
            var scale = 3.0;
            if ( params['scale'] )
            {
                scale = parseFloat(params['scale']);
                if ( isNaN(scale) ) scale = 3.0;
            }

            init();

            function init() {
                const container = document.getElementById('container');

                clock = new THREE.Clock();

                scene = new THREE.Scene();
                scene.background = new THREE.Color(0x101010);

                const light = new THREE.AmbientLight(0xffffff, 1);
                scene.add(light);

                camera = new THREE.PerspectiveCamera(
                    90,
                    window.innerWidth / window.innerHeight,
                    .1,
                    10000
                );

                var boxWidth = 1;
                var boxHeight = 1;
                var boxDepth = 1;

                const manager = new THREE.LoadingManager();
                const loader = new THREE.TextureLoader(manager);

                var cylinders = [];
                var depths;
                var pics;

                if ( params['mode'] == 'plain' ) {
                    const size = 1000;
                    // Create the panoramic sphere geometery
                    const cylinderGeom = new THREE.CylinderGeometry(
                        size,
                        size,
                        size*2,
                        360,
                        1,
                        true
                    );

                    // Load and assign the texture 
                    var cylinderMat = new THREE.ShaderMaterial({
                        side: THREE.BackSide,
                        uniforms: { tColor: { value: null } },
                        vertexShader: document.getElementById('plainVertexShader').text,
                        fragmentShader: document.getElementById('plainFragmentShader').text,
                    });

                    // Create the panoramic cylinder mesh
                    var cylinder = new THREE.Mesh(cylinderGeom,cylinderMat);

                    loader.load(
                        './cylindrical_test/frame_test' + params['scene'] + '/input.png',
                        function(texture) {
                            //texture.minFilter = THREE.LinearFilter;
                            //texture.generateMipmaps = false;
                            cylinder.material.uniforms.tColor.value = texture;
                        }
                    );

                    // On load complete add the panoramic cylinder to the scene
                    manager.onLoad = function() {
                        scene.add(cylinder);
                    };
                } else if ( params['mode'] == 'mpi' ) {
                    var some_depths = [
                        100,
                        23.846155,
                        13.537119,
                        9.45122,
                        7.259953,
                        5.893536,
                        4.96,
                        4.281768,
                        3.7667074,
                        3.362256,
                        3.0362391,
                        2.7678573,
                        2.5430682,
                        2.3520486,
                        2.1877205,
                        2.0448549,
                        1.9195048,
                        1.808635,
                        1.7098732,
                        1.6213388,
                        1.5415217,
                        1.4691944,
                        1.40335,
                        1.3431542,
                        1.2879103,
                        1.2370312,
                        1.1900192,
                        1.1464497,
                        1.105958,
                        1.0682288,
                        1.032989,
                        1
                    ];


                    for (depths = 0; depths < 32; depths++) {
                        var c = depths%4;
                        var r = Math.floor(depths/4);
                        console.log('c: ' + c)
                        console.log('r: ' + r)
                        var uv_transform = new THREE.Matrix3();
                        uv_transform.set(
                            1./4., 0., c/4.,
                            0., 1./8., r/8.,
                            0., 0., 1.);
                        console.log('transform for layer ' + depths + ': ' + uv_transform.toArray().toString());
                        var cylinderMat = new THREE.ShaderMaterial({
                            side: THREE.BackSide,
                            uniforms: { tColor: { value: null }, vUvTransform: { value: uv_transform } },
                            vertexShader: document.getElementById('mpiVertexShader').text,
                            fragmentShader: document.getElementById('mpiFragmentShader').text,
                            transparent: true
                        });

                        const cylinderGeom = new THREE.CylinderGeometry(
                            scale*some_depths[depths],
                            scale*some_depths[depths],
                            scale*2.*some_depths[depths],
                            360,
                            1,
                            true
                        );

                        const cylinder = new THREE.Mesh(
                            cylinderGeom,
                            cylinderMat
                        );

/*
                        loader.load(
                            './cylindrical_test/frame_test' + params['scene'] + '/layers/layer_' + depths.toString() + '.png',
                            function(texture) {
                                texture.generateMipmaps = false;
                                texture.minFilter = THREE.LinearFilter;
                                cylinder.material.uniforms.tColor.value = texture;
                            }
                        );
*/

                        cylinders.push(cylinder);
                    }

                    loader.load(
                        './cylindrical_test/frame_test' + params['scene'] + '/atlas.png',
                        function(texture) {
                            texture.generateMipmaps = false;
                            texture.minFilter = THREE.LinearFilter;
                            for ( depths = 0; depths < cylinders.length; depths++ )
                            {
                                cylinders[depths].material.uniforms.tColor.value = texture;
                            }
                        }
                    );

                    manager.onLoad = function() {
                    for (depths = 0; depths < cylinders.length; depths++) {
                            scene.add(cylinders[depths]);
                        }
                    };
                } else if ( params['mode'] == 'depth' ) {
                    // Create the panoramic sphere geometery
                    const cylinderGeom = new THREE.CylinderGeometry(
                        scale,
                        scale,
                        scale*2,
                        1024,
                        64,
                        true
                    );

                    // Load and assign the texture and depth map
                    var cylinderMat = new THREE.ShaderMaterial({
                        side: THREE.BackSide,
                        uniforms: { tColor: { value: null }, tDisparity: { value: null } },
                        vertexShader: document.getElementById('depthVertexShader').text,
                        fragmentShader: document.getElementById('depthFragmentShader').text,
                    });

                    // Create the panoramic cylinder mesh
                    var cylinder = new THREE.Mesh(cylinderGeom,cylinderMat);

                    loader.load(
                        './cylindrical_test/frame_test' + params['scene'] + '/input.png',
                        function(texture) {
                            texture.minFilter = THREE.LinearFilter;
                            texture.generateMipmaps = false;
                            cylinder.material.uniforms.tColor.value = texture;
                        }
                    );

                    loader.load(
                        './cylindrical_test/frame_test' + params['scene'] + '/disparity_map.png',
                        function(texture) {
                            texture.generateMipmaps = false;
                            texture.minFilter = THREE.LinearFilter;
                            cylinder.material.uniforms.tDisparity.value = texture;
                        }
                    );

                    // On load complete add the panoramic cylinder to the scene
                    manager.onLoad = function() {
                        scene.add(cylinder);
                    };
                }

                renderer = new THREE.WebGLRenderer( { alpha: true } );
                console.log('max texture size: ' + renderer.capabilities.maxTextureSize );
                renderer.setPixelRatio(window.devicePixelRatio);
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.xr.enabled = true;
                renderer.xr.setReferenceSpaceType('local');
                renderer.setAnimationLoop(render);

                //effect = new StereoEffect( renderer );
                //effect.setSize( window.innerWidth, window.innerHeight );

                container.appendChild(renderer.domElement);
                document.body.appendChild(VRButton.createButton(renderer));

                window.addEventListener('resize', onWindowResize, false);
            }

            function onWindowResize() {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();

                renderer.setSize(window.innerWidth, window.innerHeight);
                //effect.setSize( window.innerWidth, window.innerHeight );
            }
            
            const time0 = clock.getElapsedTime();
            
            function render() {
                // If we are not presenting move the camera a little so the effect is visible

                if (renderer.xr.isPresenting === false) {
                    const elapsed = clock.getElapsedTime() - time0;

                    /*camera.rotation.y += 0.001;
                    camera.position.x = Math.sin(time) * 0.05;
                    camera.position.z = Math.cos(time) * 0.05;*/

                    camera.rotation.y = -elapsed/10.;
                    camera.position.x = Math.sin(elapsed) / 3;
                }

                renderer.render(scene, camera);
                //effect.render(scene, camera);

            }
        </script>
    </body>
</html>
